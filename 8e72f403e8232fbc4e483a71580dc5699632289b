{
  "comments": [
    {
      "key": {
        "uuid": "22b91920_69e35ec1",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 4
      },
      "lineNbr": 205,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "Seems that the only client is, and will be, the init::do_mount() call... I think it\u0027s still safe and (defenitively) cleaner to avoid this wrapper function and keep that check inlined in the caller by moving the definition of this function as a static within init/builtins.cpp... are there any other users ?",
      "range": {
        "startLine": 201,
        "startChar": 0,
        "endLine": 205,
        "endChar": 1
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "609c3888_46fffc6c",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 4
      },
      "lineNbr": 242,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "We can save some indentation and perhaps improve readability by using \"continue\" whenever possible:\n\n\n    if (cnt \u003c MOUNTS_LINE_ENTRY_CGTAG) continue;\n\n    // CGroup v1 hierarchy\n    if (cnt \u003e MOUNTS_LINE_ENTRY_CGTYPE \u0026\u0026\n        !strcmp(tokens[MOUNTS_LINE_ENTRY_CGTAG], MOUNTS_CGROUP_TAG)) {\n        //...\n        continue;\n    }\n\n    // CGroup v2 hierarchy\n    if (!strcmp(tokens[MOUNTS_LINE_ENTRY_CGTAG], MOUNTS_CGROUP2_TAG)) {\n        //...\n        continue;\n    }",
      "range": {
        "startLine": 226,
        "startChar": 12,
        "endLine": 242,
        "endChar": 13
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d05a2987_5cb435b6",
        "filename": "libprocessgroup/cgroup_map.h",
        "patchSetId": 4
      },
      "lineNbr": 50,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "Why not having this logic as part of the \"singleton\" constructor and store the result as an attribute?\n\nThe init process will be the first one to call GetInstance and thus to run the detection code from the ctor().\nAll the other clients will get just an instance pointer back... IOW, all callers should just and always use GetInstance and eventually access cg_map-\u003eIsCgroupSystem(system);\n\nCould that work ?",
      "range": {
        "startLine": 48,
        "startChar": 0,
        "endLine": 50,
        "endChar": 24
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "79b4f5e8_68cdb597",
        "filename": "libprocessgroup/cgroup_map.h",
        "patchSetId": 4
      },
      "lineNbr": 56,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "With the same \"dynamic allocation\" pattern I\u0027ve suggested for TaskProfiles::GetInstance() we can get rid of the initFlag and make a better use of the constructor (instead of Init())",
      "range": {
        "startLine": 53,
        "startChar": 4,
        "endLine": 56,
        "endChar": 5
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9455632f_4423ce4d",
        "filename": "libprocessgroup/include/processgroup/processgroup.h",
        "patchSetId": 4
      },
      "lineNbr": 28,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "The only real benefit of such a mapping is compile time checks... while, if we allow users to use free form strings, we can have run-time errors/expections... but we will get a much more generic implementation.\n\nWhy not just getting rid of these mappings since the beginning?\n\nAre spelling errors really something we are worried about? These should be covered by code review... and in principle the client code should work independently from a profile being specified or not in the JSON file.",
      "range": {
        "startLine": 28,
        "startChar": 25,
        "endLine": 28,
        "endChar": 66
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7fea719a_f613ad54",
        "filename": "libprocessgroup/include/processgroup/processgroup.h",
        "patchSetId": 4
      },
      "lineNbr": 69,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "Still have to check the usages... but these methods looks like just as a wrapper for CgroupMap provided ones... do we really need them here?... if we don\u0027t have C clients I doubt...",
      "range": {
        "startLine": 68,
        "startChar": 0,
        "endLine": 69,
        "endChar": 19
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce8b92e1_371ee066",
        "filename": "libprocessgroup/include/processgroup/processgroup.h",
        "patchSetId": 4
      },
      "lineNbr": 79,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "Again a C API... need to check where we need it...",
      "range": {
        "startLine": 78,
        "startChar": 0,
        "endLine": 79,
        "endChar": 87
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "057b9624_075e86b9",
        "filename": "libprocessgroup/include/processgroup/processgroup.h",
        "patchSetId": 4
      },
      "lineNbr": 96,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-11T19:44:48Z",
      "side": 1,
      "message": "These APIs provides a \"non-profile\" based access to CGroups settings and are currently used by some runtime components like: system/core/init/service.cpp::Service::Start(). This turns out into hardcoded settings of controller values (for example the Service hardcode the swapiness levels to set for an app).\n\n\nShould we not try to get rid of them and use only profile defined settings ?\n\nThis would further simplify and consolidate the abstraction code... as well as making it simpler to experiment/test with different configurations.",
      "range": {
        "startLine": 92,
        "startChar": 0,
        "endLine": 96,
        "endChar": 75
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "89753adb_31fa278b",
        "filename": "libprocessgroup/task_profiles.cpp",
        "patchSetId": 4
      },
      "lineNbr": 227,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-11T16:22:58Z",
      "side": 1,
      "message": "I don\u0027t see any meaningful use of this return value, if we fail to build the profiles we will just end up with an empty list of actions and we cannot do much more (apart logging of course).\n\nThus, I see better this code as part of the ctor for TaskProfiles()... by getting rid of the C-ish initFlag too as suggested in one of my previous comments for the header file of this class.\n\nDo I miss something ?",
      "range": {
        "startLine": 227,
        "startChar": 0,
        "endLine": 227,
        "endChar": 3
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9172e58e_cbccf8c5",
        "filename": "libprocessgroup/task_profiles.cpp",
        "patchSetId": 4
      },
      "lineNbr": 248,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-11T16:22:58Z",
      "side": 1,
      "message": "Maybe we can save something by creating these strings only after the following conditions has been verified...\nsomething like:\n\n    for (auto attr : root[\"Attributes\"]) {\n\tstd::string name \u003d attr[\"Name\"].asString();\n\tif (attributes.find(name) !\u003d attributes.end()) {\n\t    LOG(WARNING) \u003c\u003c \"Attribute [\" \u003c\u003c name \u003c\u003c \"] already defined\";\n\t    continue;\n\t}\n\n        std::string ctrl_name \u003d attr[\"Controller\"].asString();\n\tconst struct cgroup_controller *controller \u003d\n\t\tcg_map.FindController(ctrl_name);\n\tif (!controller) {\n\t\tLOG(WARNING) \u003c\u003c \"Controller [\" \u003c\u003c ctrl_name \u003c\u003c \"] not found\";\n\t\tcontinue;\n\t}\n\n        std::string file_name \u003d attr[\"File\"].asString();\n\tattributes[name] \u003d new ProfileAttribute(controller, file_name);\n    }",
      "range": {
        "startLine": 247,
        "startChar": 8,
        "endLine": 248,
        "endChar": 59
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "07b27863_4243bbe8",
        "filename": "libprocessgroup/task_profiles.cpp",
        "patchSetId": 4
      },
      "lineNbr": 268,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-11T16:22:58Z",
      "side": 1,
      "message": "I think these two lines could be reduced to:\n\n    for (auto profileVal : profilesVal) {",
      "range": {
        "startLine": 267,
        "startChar": 4,
        "endLine": 268,
        "endChar": 48
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bbd100df_505957f6",
        "filename": "libprocessgroup/task_profiles.cpp",
        "patchSetId": 4
      },
      "lineNbr": 275,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-11T16:22:58Z",
      "side": 1,
      "message": "Maybe just:\n\n    for (auto \u0026actionVal : actions) {",
      "range": {
        "startLine": 274,
        "startChar": 7,
        "endLine": 275,
        "endChar": 52
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49ec4c1b_05e44c7d",
        "filename": "libprocessgroup/task_profiles.cpp",
        "patchSetId": 4
      },
      "lineNbr": 289,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-11T16:22:58Z",
      "side": 1,
      "message": "All the following IF statements looks like factory code... it would fit better in the base class, something like:\n \n \nProfileElement *ProfileElement::GetInstance(std::string const \u0026name, Json::Value values) {\n\n\tif (name \u003d\u003d \"JoinCgroup\") {\n\t\tstd::string ctrlName \u003d values[\"Controller\"].asString();\n\t\tstd::string path \u003d values[\"Path\"].asString();\n\t\tconst CgroupMap \u0026cg_map \u003d CgroupMap::GetInstance();\n\n\t\tconst auto *controller \u003d cg_map.FindController(ctrlName.c_str());\n\t\tif (!controller) {\n\t\t\tLOG(WARNING) \u003c\u003c \"JoinCgroup: controller \" \u003c\u003c ctrlName \u003c\u003c \" is not found\";\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn new SetCgroupAction(controller, path);\n\t}\n\n\tif (name \u003d\u003d \"SetTimerSlack\") {\n\t\tstd::string slackValue \u003d values[\"Slack\"].asString();\n\t\tunsigned long slack;\n\t\tchar *end;\n\n\t\tslack \u003d strtoul(slackValue.c_str(), \u0026end, 10);\n\t\tif (end \u003c\u003d slackValue.c_str()) {\n\t\t\tLOG(WARNING) \u003c\u003c \"SetTimerSlack: invalid parameter: \" \u003c\u003c slackValue;\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn new SetTimerSlackAction(slack);\n\t}\n\n        // Other cases here...\n\n        LOG(WARNING) \u003c\u003c \"Unknown profile action: \" \u003c\u003c name;\n\treturn NULL;\n}\n\n\nWhich will reduce this loop to:\n\n\n        profile \u003d new TaskProfile();\n        for (auto \u0026actionVal : actions) {\n            std::string actionName \u003d actionVal[\"Name\"].asString();\n            Json::Value paramsVal \u003d actionVal[\"Params\"];\n\n\t    auto action \u003d ProfileElement::GetInstance(actionName, paramsVal);\n\t    if (action)\n\t\t    profile-\u003eAdd(action);\n        }\n\n\nAnd... as per another comments of mine, I would suggest to s/ProfileElement/ProfileAction/",
      "range": {
        "startLine": 278,
        "startChar": 12,
        "endLine": 289,
        "endChar": 13
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e67ace8a_f4d001fb",
        "filename": "libprocessgroup/task_profiles.cpp",
        "patchSetId": 4
      },
      "lineNbr": 340,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-11T16:22:58Z",
      "side": 1,
      "message": "I think we can get a cleaner code by avoiding this global and moving this check into the SetTimerSlackAction ctor.\nWe currently have only two SetTimerSlack actions defined... and even if we should have more, this check is done once at profiles creation only... thus it can be worth to prioritise code cleanup.\n\nMoreover, why not get rid of set_timerslack_ns() and move its code directly within:\n   SetTimerSlackAction::ExecuteForTask()\nAFAIKS there are not other clients for that API.",
      "range": {
        "startLine": 339,
        "startChar": 4,
        "endLine": 340,
        "endChar": 51
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9eb26c81_a698ca5e",
        "filename": "libprocessgroup/task_profiles.cpp",
        "patchSetId": 4
      },
      "lineNbr": 342,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-11T16:22:58Z",
      "side": 1,
      "message": "Why passing it as parameter? Cannot we just get an instance from within the method itself ?",
      "range": {
        "startLine": 342,
        "startChar": 28,
        "endLine": 342,
        "endChar": 52
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "be683ebf_b1d0bf0f",
        "filename": "libprocessgroup/task_profiles.h",
        "patchSetId": 4
      },
      "lineNbr": 38,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "Did not yet has a look at the clients... but not returning a path string here looks a bit too much C then C++...",
      "range": {
        "startLine": 38,
        "startChar": 8,
        "endLine": 38,
        "endChar": 22
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc48a949_1d05e13f",
        "filename": "libprocessgroup/task_profiles.h",
        "patchSetId": 4
      },
      "lineNbr": 42,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "Give we always specialise *Action classes from this base, should not be something like \"ProfilewAction\" a better name for this class? At the end it\u0027s there to translate a profile into a set of actions...",
      "range": {
        "startLine": 42,
        "startChar": 6,
        "endLine": 42,
        "endChar": 20
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b9ecfb88_2ff86cf2",
        "filename": "libprocessgroup/task_profiles.h",
        "patchSetId": 4
      },
      "lineNbr": 54,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "unsigned int looks a better type for uclamp attributes",
      "range": {
        "startLine": 54,
        "startChar": 4,
        "endLine": 54,
        "endChar": 7
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc8c1e68_7a6a661f",
        "filename": "libprocessgroup/task_profiles.h",
        "patchSetId": 4
      },
      "lineNbr": 106,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "If we go for s/TaskProfile/ProfileAction/ this will be \"actions\"",
      "range": {
        "startLine": 106,
        "startChar": 16,
        "endLine": 106,
        "endChar": 41
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f591f05a_047122b2",
        "filename": "libprocessgroup/task_profiles.h",
        "patchSetId": 4
      },
      "lineNbr": 106,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-11T16:22:58Z",
      "side": 1,
      "message": "Here I was meaning, if we for for s/ProfileElement/ProfileAction/ .... sorry for the confusion",
      "parentUuid": "dc8c1e68_7a6a661f",
      "range": {
        "startLine": 106,
        "startChar": 16,
        "endLine": 106,
        "endChar": 41
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e5fff9d_e42e5274",
        "filename": "libprocessgroup/task_profiles.h",
        "patchSetId": 4
      },
      "lineNbr": 120,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-11T17:59:19Z",
      "side": 1,
      "message": "I\u0027m not convinced about tracking attributes within this class.\nThe only \"advantage\" is a single JSON parsing code... but for that we end up with a tight dependency between attributes and profiles.\n\nWhat about moving attributes parsing code within a dedicated ProfileAttributes class?\n\nThis will give us a dual implementation:\n- TaskProfiles is a container or TaskProfile\n- ProfileAttributes is a container or ProfileAttribute\n\nEvery class is in charge to parse its data... and since ProfileAttributes is a singleton, the first time we get an instance of it (i.e. from ProfileElement::GetInstance(name\u003d\"SetAttribute\")) it will take care to parse the JSON to build the attributes DB.\n\nIn principle, the JSON file could also be split in \"task_profiles.json\" and \"task_attributes.json\", isn\u0027t it ?\nIn principle, we don\u0027t need to parse the attributes if there are not SetAttribute actions defined by profiles.",
      "range": {
        "startLine": 120,
        "startChar": 4,
        "endLine": 120,
        "endChar": 56
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6321c35e_9ad35200",
        "filename": "libprocessgroup/task_profiles.h",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "Still to look at the clients... but this looks like something we should do from the ctor...",
      "range": {
        "startLine": 128,
        "startChar": 4,
        "endLine": 128,
        "endChar": 38
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "704d4992_dd3b0c77",
        "filename": "libprocessgroup/task_profiles.h",
        "patchSetId": 4
      },
      "lineNbr": 137,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "We can avoid the InitFlag and simplify a bit the code if we go for dynamic allocation at first call:\n\nstatic const TaskProfiles* GetInstance() {\n    static TaskProfiles *instance;\n\n    if (!instance)\n        instance \u003d new TaskProfiles();\n\n    return instance;\n}\n\nAnd moving the Init() code into the ctor.",
      "range": {
        "startLine": 134,
        "startChar": 4,
        "endLine": 137,
        "endChar": 5
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49361981_92552e01",
        "filename": "libprocessgroup/utils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 44,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "Here we can save some code duplication by calling the following Chown().\n\nMoreover, all these methods looks like they could be better organised withing a \"Path\" class, e.g.\n\nclass Path {\npublic:\n    Path(const std::string\u0026 path);\n    bool mkdir(mode_t mode);\n    bool chown(uid_t uid, gid_t gid);\n    // Other UID/PID related methods can be moved here too...\n};\n// Eventually specialised by:\nclass CGroupPath { };\n\n\nDon\u0027t we ready have something generic around for path manipulations ?",
      "range": {
        "startLine": 39,
        "startChar": 4,
        "endLine": 44,
        "endChar": 5
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "61a6cfca_ee9eff6b",
        "filename": "libprocessgroup/utils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 49,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "What about using a:\n   vector\u003cchar *\u003e \u0026tokens\n?",
      "range": {
        "startLine": 49,
        "startChar": 51,
        "endLine": 49,
        "endChar": 80
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b278fe8_64a72dd5",
        "filename": "libprocessgroup/utils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 69,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-10T18:59:25Z",
      "side": 1,
      "message": "Is this not just:\n\n        str.replace(pos, from.length(), to);\n\n?",
      "range": {
        "startLine": 68,
        "startChar": 8,
        "endLine": 69,
        "endChar": 28
      },
      "revId": "8e72f403e8232fbc4e483a71580dc5699632289b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}