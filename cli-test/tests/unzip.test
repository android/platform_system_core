# unzip tests.

# Note: since "master key", Android uses libziparchive for all zip file
# handling, and that scans the whole central directory immediately. Not only
# lookups by name but also iteration is implemented using the resulting hash
# table, meaning that any test that makes assumptions about iteration order
# will fail on Android.

name: unzip -l
command: unzip -l $FILES/example.zip d1/d2/x.txt
after: [ ! -f d1/d2/x.txt ]
expected-stdout:
	Archive:  $FILES/example.zip
	  Length      Date    Time    Name
	---------  ---------- -----   ----
	     1024  2017-06-04 08:45   d1/d2/x.txt
	---------                     -------
	     1024                     1 file
---

name: unzip -lq
command: unzip -lq $FILES/example.zip d1/d2/x.txt
after: [ ! -f d1/d2/x.txt ]
expected-stdout:
	  Length      Date    Time    Name
	---------  ---------- -----   ----
	     1024  2017-06-04 08:45   d1/d2/x.txt
	---------                     -------
	     1024                     1 file
---

name: unzip -lv
command: unzip -lv $FILES/example.zip d1/d2/x.txt
after: [ ! -f d1/d2/file ]
expected-stdout:
	Archive:  $FILES/example.zip
	 Length   Method    Size  Cmpr    Date    Time   CRC-32   Name
	--------  ------  ------- ---- ---------- ----- --------  ----
	    1024  Defl:N       11  99% 2017-06-04 08:45 48d7f063  d1/d2/x.txt
	--------          -------  ---                            -------
	    1024               11  99%                            1 file
---

name: unzip -v
command: unzip -v $FILES/example.zip d1/d2/x.txt
after: [ ! -f d1/d2/file ]
expected-stdout:
	Archive:  $FILES/example.zip
	 Length   Method    Size  Cmpr    Date    Time   CRC-32   Name
	--------  ------  ------- ---- ---------- ----- --------  ----
	    1024  Defl:N       11  99% 2017-06-04 08:45 48d7f063  d1/d2/x.txt
	--------          -------  ---                            -------
	    1024               11  99%                            1 file
---

name: unzip one file
command: unzip -q $FILES/example.zip d1/d2/a.txt && cat d1/d2/a.txt
after: [ ! -f d1/d2/b.txt ]
expected-stdout:
	a
---

name: unzip all files
command: unzip -q $FILES/example.zip
after: [ -f d1/d2/a.txt ]
after: [ -f d1/d2/b.txt ]
after: [ -f d1/d2/c.txt ]
after: [ -f d1/d2/empty.txt ]
after: [ -f d1/d2/x.txt ]
after: [ -d d1/d2/dir ]
expected-stdout:
---

name: unzip -o
before: mkdir -p d1/d2
before: echo b > d1/d2/a.txt
command: unzip -q -o $FILES/example.zip d1/d2/a.txt && cat d1/d2/a.txt
expected-stdout:
	a
---

name: unzip -n
before: mkdir -p d1/d2
before: echo b > d1/d2/a.txt
command: unzip -q -n $FILES/example.zip d1/d2/a.txt && cat d1/d2/a.txt
expected-stdout:
	b
---

name: unzip -d non-existent
# Note: the RI exits with a wide variety of random exit codes.
command: unzip -q -d will/not/be/created $FILES/example.zip d1/d2/a.txt 2> /dev/null || echo expected-error-exit
after: [ ! -d will ]
expected-stdout:
	expected-error-exit
---

name: unzip -d exists
before: mkdir dir
command: unzip -q -d dir $FILES/example.zip d1/d2/a.txt && cat dir/d1/d2/a.txt
after: [ ! -f d1/d2/a.txt ]
expected-stdout:
	a
---

name: unzip -p
command: unzip -p $FILES/example.zip d1/d2/a.txt
after: [ ! -f d1/d2/a.txt ]
expected-stdout:
	a
---

name: unzip -x FILE...
# Note: the RI ignores -x DIR for some reason, but it's not obvious we should.
command: unzip -q $FILES/example.zip -x d1/d2/a.txt d1/d2/b.txt d1/d2/empty.txt d1/d2/x.txt && cat d1/d2/c.txt
after: [ ! -f d1/d2/a.txt ]
after: [ ! -f d1/d2/b.txt ]
after: [ ! -f d1/d2/empty.txt ]
after: [ ! -f d1/d2/x.txt ]
after: [ -d d1/d2/dir ]
expected-stdout:
	ccc
---

name: unzip FILE -x FILE...
command: unzip -q $FILES/example.zip d1/d2/a.txt d1/d2/b.txt -x d1/d2/a.txt && cat d1/d2/b.txt
after: [ ! -f d1/d2/a.txt ]
after: [ -f d1/d2/b.txt ]
after: [ ! -f d1/d2/c.txt ]
after: [ ! -f d1/d2/empty.txt ]
after: [ ! -f d1/d2/x.txt ]
after: [ ! -d d1/d2/dir ]
expected-stdout:
	bb
---
