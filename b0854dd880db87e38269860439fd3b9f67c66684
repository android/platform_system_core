{
  "comments": [
    {
      "key": {
        "uuid": "c9202290_d431fa42",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-02T18:32:00Z",
      "side": 1,
      "message": "prefer to split these up if you can, since we run the fuzzers independently, and fixes can be merged independently (also, this would make the commit title to be able to be more specific)",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 14,
        "endChar": 0
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8dbf8a7e_364da34c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-02T20:19:32Z",
      "side": 1,
      "message": "Gotcha, probably makes the most sense to bundle these as rwlock removal, refbase rewrite, and string8 rewrite.",
      "parentUuid": "c9202290_d431fa42",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 14,
        "endChar": 0
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0945ca29_3e1099fe",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 15,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-02T18:32:00Z",
      "side": 1,
      "message": "btw, do you have access to the test cases discovered by our infra?\n\nAlso, do you artificially lower the memory limit, out of curiousity?\n\nPlease prefer to add exact commands used in \u0027Test\u0027 line",
      "range": {
        "startLine": 15,
        "startChar": 0,
        "endLine": 15,
        "endChar": 81
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dbde0994_d39d006b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 15,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-02T20:19:32Z",
      "side": 1,
      "message": "1. We might, but don\u0027t know where we\u0027d find it, and are unable to export/run it from google machines, so effectively no. \n2. We don\u0027t explicitly limit it, but oss-fuzz might be using default libfuzzer limits before it considers it a bug",
      "parentUuid": "0945ca29_3e1099fe",
      "range": {
        "startLine": 15,
        "startChar": 0,
        "endLine": 15,
        "endChar": 81
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "74bd7b39_b4bedeaf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-01T23:35:04Z",
      "side": 1,
      "message": "It\u0027s worth noting that there is a memory leak in RefBase_fuzz.cpp, but it appears to only happen on host, leading me to suspect it may be an issue with the library. It\u0027s caught almost immediately by the leak sanitizer.",
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7b8dcb41_eacc5441",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-02T20:41:48Z",
      "side": 1,
      "message": "Alright, going to abandon this CL and open new ones with the changes we\u0027ve discussed. Feel free to let me know if you think of anything else that should be improved design-wise. Thanks!",
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4ce04d54_adb5f01f",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-02T18:32:00Z",
      "side": 1,
      "message": "this is implicitly holding a strong ref, which we may not want, since we would avoid testing the case where the ref is deleted",
      "range": {
        "startLine": 34,
        "startChar": 0,
        "endLine": 34,
        "endChar": 24
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c7d2434_fcce248b",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-02T20:19:32Z",
      "side": 1,
      "message": "That\u0027s a good point. We went back in forth on this a few times. Initially this was just a RefBaseSubclass object, but that created a memory leak. Then I added a delete, but since ref objects can delete themselves, it lead to double free problems. I also tried using a shared_ptr, but that had issues and there\u0027s a big warning in RefBase against doing that. sp seemed to be the most common use case, but yeah, it modifies refs, which I can see being problematic. Just to be clear, as long as this retains at least one weak or strong ref, it shouldn\u0027t be deleted, correct?",
      "parentUuid": "4ce04d54_adb5f01f",
      "range": {
        "startLine": 34,
        "startChar": 0,
        "endLine": 34,
        "endChar": 24
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "724bb864_a5375c3a",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-02T20:36:07Z",
      "side": 1,
      "message": "I think a raw pointer is best because we are testing RefBase methods themselves. It may become invalid, but you could keep track of this (only call methods on it when you know it isn\u0027t deleted).",
      "parentUuid": "8c7d2434_fcce248b",
      "range": {
        "startLine": 34,
        "startChar": 0,
        "endLine": 34,
        "endChar": 24
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d9a5c0e_040b6271",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-02T18:32:00Z",
      "side": 1,
      "message": "all of this locking removes a bit of coverage from the test, since incStrong/decWeak, for instance are allowed together. The problem is one thread doing a decWeak of the reference that incStrong owns locally.\n\nLet me suggest an alternative setup (independent thread ownership) which would retain coverage w/o having this \u0027stealing ref\u0027 problem:\n\nstruct ThreadState {\n    size_t strong_count \u003d 0;\n    size_t weak_count \u003d 0;\n};\n\nstd::vector\u003cstd::function\u003cvoid(ThreadState*)\u003e operations \u003d {\n    [](ThreadState* state) -\u003e void {\n        ref-\u003eincStrong();\n        state-\u003estrong_count++;\n    },\n    ...\n};\n\nEach thread would clean up references independently, and this way you never have a situation where one thread assumes it has ownership of a reference that another thread would take locally.",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 29
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "31b706e9_ae79cddf",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-02T20:19:32Z",
      "side": 1,
      "message": "Hmm okay. I suppose that makes sense. In general this fuzzer has proven very temperamental/brittle, especially since ref objects can delete themselves.",
      "parentUuid": "8d9a5c0e_040b6271",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 29
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "826575bb_1b313c2e",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-02T20:36:07Z",
      "side": 1,
      "message": "Yeah, and you would also want to avoid calling methods on ref in the case that all ThreadState objects had zero counts.",
      "parentUuid": "31b706e9_ae79cddf",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 29
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4aff4905_67565620",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 70,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-02T18:32:00Z",
      "side": 1,
      "message": "yeah, but it maps to the weak decrement implicitly added in incStrong",
      "range": {
        "startLine": 70,
        "startChar": 0,
        "endLine": 70,
        "endChar": 57
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a66504d2_81b8f8e4",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 140,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-02T18:32:00Z",
      "side": 1,
      "message": "the sp\u003c\u003e implicitly holds a strong ref of the object, so this should never be true.\n\nAlso, as mentioned above, it seems the fuzzer might put the object in a bad state where it has no weak refs but still strong refs, OR this misses removing remaining weak references after all strong references are removed (this should leave some state sitting around)",
      "range": {
        "startLine": 140,
        "startChar": 11,
        "endLine": 140,
        "endChar": 14
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f1b10285_49fd7885",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 140,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-02T20:19:32Z",
      "side": 1,
      "message": "Gotcha, I think swapping to the per-thread state tracking will make this a lot more robust, and should hopefully resolve this.",
      "parentUuid": "a66504d2_81b8f8e4",
      "range": {
        "startLine": 140,
        "startChar": 11,
        "endLine": 140,
        "endChar": 14
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f6a67b51_5eb95916",
        "filename": "libutils/String8_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-02T20:36:07Z",
      "side": 1,
      "message": "make static const, also prefer kFormatChars (you could also restrict the scope of this)",
      "range": {
        "startLine": 28,
        "startChar": 12,
        "endLine": 28,
        "endChar": 23
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "09dc3480_60927248",
        "filename": "libutils/String8_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-02T20:41:48Z",
      "side": 1,
      "message": "Will probably lean towards static const just to avoid allocating a new string every loop.",
      "parentUuid": "f6a67b51_5eb95916",
      "range": {
        "startLine": 28,
        "startChar": 12,
        "endLine": 28,
        "endChar": 23
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "55607424_c57cebd9",
        "filename": "libutils/String8_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 122,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-02T18:32:00Z",
      "side": 1,
      "message": "what are all these magic constants? indexes into formatChars?",
      "range": {
        "startLine": 122,
        "startChar": 21,
        "endLine": 122,
        "endChar": 22
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8200c8c3_6c325681",
        "filename": "libutils/String8_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 122,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-02T20:19:32Z",
      "side": 1,
      "message": "Yes, different types allow for different modifiers. For instance, precision is only useful for decimal types. I figured this was slightly more eloquent than checking each character independently, although that may be a more explicit/clear way of doing it...",
      "parentUuid": "55607424_c57cebd9",
      "range": {
        "startLine": 122,
        "startChar": 21,
        "endLine": 122,
        "endChar": 22
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "750c166d_9df9521d",
        "filename": "libutils/String8_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 122,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-02T20:36:07Z",
      "side": 1,
      "message": "Yeah, this is a bit hard to read w/ the indexes, if it could be more explicit, that would be great. For instance, it\u0027s not clear how we could add an additional format character.",
      "parentUuid": "8200c8c3_6c325681",
      "range": {
        "startLine": 122,
        "startChar": 21,
        "endLine": 122,
        "endChar": 22
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ddfdd7fa_0cbbfdb8",
        "filename": "libutils/String8_fuzz.cpp",
        "patchSetId": 1
      },
      "lineNbr": 122,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-09-02T20:41:48Z",
      "side": 1,
      "message": "It\u0027s a bit tricky. I think a better way to do this might be with an enum for format modifiers and string characters. That would make this a lot less magic, although it might be slightly more verbose.",
      "parentUuid": "750c166d_9df9521d",
      "range": {
        "startLine": 122,
        "startChar": 21,
        "endLine": 122,
        "endChar": 22
      },
      "revId": "b0854dd880db87e38269860439fd3b9f67c66684",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}