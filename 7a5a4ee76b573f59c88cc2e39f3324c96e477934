{
  "comments": [
    {
      "key": {
        "uuid": "20f1bbf8_62ca6b84",
        "filename": "libunwindstack/RegsArm64.cpp",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2020-01-25T00:45:57Z",
      "side": 1,
      "message": "ARM manual says: PAC is replaced with the extension bits, which don\u0027t hold valid address bits.\nAre the extension bits all zero?\n\nCan we know the extension bits of current processor? So we can keep it in files and use it in offline unwinding which may happen on another processor.",
      "range": {
        "startLine": 60,
        "startChar": 29,
        "endLine": 60,
        "endChar": 31
      },
      "revId": "7a5a4ee76b573f59c88cc2e39f3324c96e477934",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3ffe33dc_af875835",
        "filename": "libunwindstack/RegsArm64.cpp",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1626440
      },
      "writtenOn": "2020-01-27T10:31:48Z",
      "side": 1,
      "message": "Hi Yabin,\n\nFor userspace pointers the extension bits are all zero, for kernel pointers they are all one. In general they all have the value of bit 55.\n\nOn Linux you can query which bits to strip by asking for NT_ARM_PAC_MASK in a PTRACE_GETREGSET. Otherwise you can execute XPACLRI on a pointer in which every bit is the same but bit 55 is negated to see which bits are changed. You can save this and use it on other configurations.",
      "parentUuid": "20f1bbf8_62ca6b84",
      "range": {
        "startLine": 60,
        "startChar": 29,
        "endLine": 60,
        "endChar": 31
      },
      "revId": "7a5a4ee76b573f59c88cc2e39f3324c96e477934",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa6a0c99_70ba4884",
        "filename": "libunwindstack/RegsArm64.cpp",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1056364
      },
      "writtenOn": "2020-01-27T20:45:34Z",
      "side": 1,
      "message": "Thanks for the info. This matches what kernel uses for stripping PAC, \u0026 ~MASK in https://github.com/torvalds/linux/blob/master/arch/arm64/include/asm/pointer_auth.h#L77.\n\nlibunwindstack currently supports unwinding arm/arm64/x86/x86_64 on any of these archs. This is useful to simpleperf in below ways:\n  1. we only build one arm64 simpleperf binary on device, and it can unwind both arm/arm64 stacks.\n  2. simpleperf supports generating stacks on device, and unwinding them on host. This is not the default way, but we do support it.\n  3. both simpleperf and libunwindstack contain test data files with recorded stack for unwinding regression tests.\n\nSo I prefer to keep unwinding arm64 code possible on other archs and devices:\n  1. have a way to pass PTR_AUTH_USER_SPACE_MASK to RegsArm64, and use \u0026~PTR_AUTH_USER_SPACE_MASK instead of XPACLRI in set_pc.\n  2. not limit DW_CFA_AARCH64_negate_ra_state build to arm64.",
      "parentUuid": "3ffe33dc_af875835",
      "range": {
        "startLine": 60,
        "startChar": 29,
        "endLine": 60,
        "endChar": 31
      },
      "revId": "7a5a4ee76b573f59c88cc2e39f3324c96e477934",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}