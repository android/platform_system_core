{
  "comments": [
    {
      "key": {
        "uuid": "cc155a3a_9c01e751",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 262,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-17T12:34:57Z",
      "side": 1,
      "message": "Right now we call detect each time we mount a new cgroup from init.\nThis generates a dependency between this module and the init scripts,\nwhich perhaps we can get rid of.\n\nWhat about a different design, based on \"lazy\" initialisation, where:\n\n1) the CgroupMap singleton detects all the available controllers by parsing\n      /proc/cgroups\n   from its ctor the very first time someone get an instance\n   (CgroupMap dynamic allocation helps in this case)\n\n2) the ctor builds and maintains a map of:\n      ControllerName to \u003cHierarchyID,MountPoint\u003e\n   when the ctor runs we build the above map in one go for all the possible controller,\n   by simply parsing \"/proc/cgroups\", that file does not report the mount points but...\n\n3) ... a private method is provided to identify the mount point of a given controller\n   by reading it from \"/proc/mounts\"\n\n4) the same private method in 3 can be used on-demand to resolve all the not mapped\n   mountpoints every time a new client ask for a controller,\n   i.e. from ::FindController()\n\nSince the CgroupMap construction is deferret to the first time a CgroupMap client needs to use a controller,\nwe are more likely to have already mounted all the required cgroups (i.e. init completed) and thus to end up with a single parsing/mapping stage.",
      "range": {
        "startLine": 262,
        "startChar": 0,
        "endLine": 262,
        "endChar": 24
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f84b325d_ae3eab61",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 262,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-01-17T17:27:01Z",
      "side": 1,
      "message": "The issue with init script is that cgroups are mounted not all at the same time. So it mounts cpuacct and memory early on, then starts using them and then it mounts the rest of the controllers. That\u0027s the reason I have to support \"incremental\" detection.",
      "parentUuid": "cc155a3a_9c01e751",
      "range": {
        "startLine": 262,
        "startChar": 0,
        "endLine": 262,
        "endChar": 24
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aec03e79_db89c450",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 262,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-01-18T02:59:41Z",
      "side": 1,
      "message": "Ok, I understand now your suggestion. The issue I see is that /proc/cgroups does not contain cgroup v2 controllers. So unfortunately step #2 will fail to identify all controllers. It will also contain controllers that we never mount...\nBesides if I understood this correctly, it will parse /proc/mounts the same number of times because we don\u0027t really mount any cgroup that we don\u0027t use.\nLet\u0027s discuss this some more.",
      "parentUuid": "f84b325d_ae3eab61",
      "range": {
        "startLine": 262,
        "startChar": 0,
        "endLine": 262,
        "endChar": 24
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "59c016b7_586107eb",
        "filename": "libprocessgroup/processgroup.cpp",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-01-16T22:59:28Z",
      "side": 1,
      "message": "Tom had a comment why I need these instead of exposing CgroupMap directly.\nI don\u0027t expose CgroupMap outside of libprocessgroup considering it\u0027s an implementation detail. If needed I can move cgroup_map.h header into include/processgroup/ and eliminate these functions.",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 64,
        "endChar": 2
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5cc4d54d_2baf0f96",
        "filename": "libprocessgroup/processgroup.cpp",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-17T12:34:57Z",
      "side": 1,
      "message": "I think the important part is to not leak hard-coded paths... while exposing CgroupMap I think is still possible and actually probably makes more sense and keep things simple for cases like the eBPF integration.\nMore details on my last comment for:\n   libbpf_android/BpfUtils.cpp::loadAndPinProgram()",
      "parentUuid": "59c016b7_586107eb",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 64,
        "endChar": 2
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}