{
  "comments": [
    {
      "key": {
        "uuid": "14ad2319_929cfcfa",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 79,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2019-01-18T18:59:24Z",
      "side": 1,
      "message": "Why not return an std::optional\u003cstd::string\u003e?",
      "range": {
        "startLine": 79,
        "startChar": 0,
        "endLine": 79,
        "endChar": 4
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "717c3bd4_831afc45",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 92,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2019-01-18T18:59:24Z",
      "side": 1,
      "message": "$ cat /proc/$$/cgroup | wc -c\n330\n\nPlease just slurp the entire file instead of imposing an arbitrary limit.",
      "range": {
        "startLine": 92,
        "startChar": 13,
        "endLine": 92,
        "endChar": 16
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb57f6bb_c2e6f299",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 120,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2019-01-18T18:59:24Z",
      "side": 1,
      "message": "Why not build a new string from the non-matches pieces and replacement, then assign into the destination? This code seems to shuffle bytes unnecessarily by using in-place operations.",
      "range": {
        "startLine": 120,
        "startChar": 12,
        "endLine": 120,
        "endChar": 17
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eba26ed9_8bebbcc3",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 148,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2019-01-18T18:59:24Z",
      "side": 1,
      "message": "Abort on failure please",
      "range": {
        "startLine": 148,
        "startChar": 8,
        "endLine": 148,
        "endChar": 14
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "14ee53c2_2c4ef7cc",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 157,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2019-01-18T18:59:24Z",
      "side": 1,
      "message": "IMHO, it\u0027s very surprising to see an rmdir in the cleanup path of a function that\u0027s supposed to just change ownership",
      "range": {
        "startLine": 157,
        "startChar": 8,
        "endLine": 157,
        "endChar": 13
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cc155a3a_9c01e751",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 262,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-17T12:34:57Z",
      "side": 1,
      "message": "Right now we call detect each time we mount a new cgroup from init.\nThis generates a dependency between this module and the init scripts,\nwhich perhaps we can get rid of.\n\nWhat about a different design, based on \"lazy\" initialisation, where:\n\n1) the CgroupMap singleton detects all the available controllers by parsing\n      /proc/cgroups\n   from its ctor the very first time someone get an instance\n   (CgroupMap dynamic allocation helps in this case)\n\n2) the ctor builds and maintains a map of:\n      ControllerName to \u003cHierarchyID,MountPoint\u003e\n   when the ctor runs we build the above map in one go for all the possible controller,\n   by simply parsing \"/proc/cgroups\", that file does not report the mount points but...\n\n3) ... a private method is provided to identify the mount point of a given controller\n   by reading it from \"/proc/mounts\"\n\n4) the same private method in 3 can be used on-demand to resolve all the not mapped\n   mountpoints every time a new client ask for a controller,\n   i.e. from ::FindController()\n\nSince the CgroupMap construction is deferret to the first time a CgroupMap client needs to use a controller,\nwe are more likely to have already mounted all the required cgroups (i.e. init completed) and thus to end up with a single parsing/mapping stage.",
      "range": {
        "startLine": 262,
        "startChar": 0,
        "endLine": 262,
        "endChar": 24
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f84b325d_ae3eab61",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 262,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-01-17T17:27:01Z",
      "side": 1,
      "message": "The issue with init script is that cgroups are mounted not all at the same time. So it mounts cpuacct and memory early on, then starts using them and then it mounts the rest of the controllers. That\u0027s the reason I have to support \"incremental\" detection.",
      "parentUuid": "cc155a3a_9c01e751",
      "range": {
        "startLine": 262,
        "startChar": 0,
        "endLine": 262,
        "endChar": 24
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aec03e79_db89c450",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 262,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-01-18T02:59:41Z",
      "side": 1,
      "message": "Ok, I understand now your suggestion. The issue I see is that /proc/cgroups does not contain cgroup v2 controllers. So unfortunately step #2 will fail to identify all controllers. It will also contain controllers that we never mount...\nBesides if I understood this correctly, it will parse /proc/mounts the same number of times because we don\u0027t really mount any cgroup that we don\u0027t use.\nLet\u0027s discuss this some more.",
      "parentUuid": "f84b325d_ae3eab61",
      "range": {
        "startLine": 262,
        "startChar": 0,
        "endLine": 262,
        "endChar": 24
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc6252ed_647e91cd",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 262,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-01-19T03:01:14Z",
      "side": 1,
      "message": "Do you know why the cgroups aren\u0027t all mounted early on?\n\nThere shouldn\u0027t be anything stopping us from making it a policy that \"all cgroups must be mounted during early-init\" and never needing to run this Detect() function more than once.\n\nThat seems a lot more reasonable to me than needing to call detect during each mount.",
      "parentUuid": "aec03e79_db89c450",
      "range": {
        "startLine": 262,
        "startChar": 0,
        "endLine": 262,
        "endChar": 24
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c239756e_cd4e59b4",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 262,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-21T17:04:17Z",
      "side": 1,
      "message": "If we can force mounts all cgroups at early-init that would be great!\nBut, would not be difficult to enforce? Mainly only via code review, isn\u0027t it?\n\nHowever, as per off-line discussion with Surne, the parsing of \"/proc/cgroup\" I\u0027m describing above is not really required. While \"/proc/mounts\" can still be lazy parsed on-demand, whenever a client actually uses the API.\nBy just doing that we should reduce the number of required parsing to a max of two, if all cgroup mount can happen only at early- and late-init.",
      "parentUuid": "fc6252ed_647e91cd",
      "range": {
        "startLine": 262,
        "startChar": 0,
        "endLine": 262,
        "endChar": 24
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90ae8c80_0b0fd762",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 262,
      "author": {
        "id": 1064128
      },
      "writtenOn": "2019-01-21T19:49:28Z",
      "side": 1,
      "message": "\u003e If we can force mounts all cgroups at early-init that would be great!\nBut, would not be difficult to enforce? Mainly only via code review, isn\u0027t it?\n\nIf we only detected them once, then cgroups mounted after that point would simply not work with this new API, so that\u0027d be it\u0027s own enforcement mechanism.\n\nBut I don\u0027t think that\u0027s the right thing to do.  I think the other comment thread we have, discussing having the cgroups mounted by this library, is the right approach.",
      "parentUuid": "c239756e_cd4e59b4",
      "range": {
        "startLine": 262,
        "startChar": 0,
        "endLine": 262,
        "endChar": 24
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c39872a3_10396031",
        "filename": "libprocessgroup/cgroup_map.cpp",
        "patchSetId": 6
      },
      "lineNbr": 262,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-23T17:25:06Z",
      "side": 1,
      "message": "Lazy detection at CgroupMap::FindController() should always work, provided a controller is available from kernel space and init script ensure it\u0027s mounted before spawning clients.\n\nHowever, if possible within the scope/timeframe of this CL to get move the mounting code within this class, that\u0027s the best way to go for me too.",
      "parentUuid": "90ae8c80_0b0fd762",
      "range": {
        "startLine": 262,
        "startChar": 0,
        "endLine": 262,
        "endChar": 24
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ad6b42f_d04b6685",
        "filename": "libprocessgroup/cgroup_map.h",
        "patchSetId": 6
      },
      "lineNbr": 34,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2019-01-18T18:59:24Z",
      "side": 1,
      "message": "Nit: why not std::string_view (or const char*) onto the internal buffer? Why make a copy?",
      "range": {
        "startLine": 34,
        "startChar": 4,
        "endLine": 34,
        "endChar": 15
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a0901bd_f8ee90f8",
        "filename": "libprocessgroup/cgroup_map.h",
        "patchSetId": 6
      },
      "lineNbr": 43,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2019-01-18T18:59:24Z",
      "side": 1,
      "message": "Why not just store an std::string?",
      "range": {
        "startLine": 43,
        "startChar": 3,
        "endLine": 43,
        "endChar": 34
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "59c016b7_586107eb",
        "filename": "libprocessgroup/processgroup.cpp",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-01-16T22:59:28Z",
      "side": 1,
      "message": "Tom had a comment why I need these instead of exposing CgroupMap directly.\nI don\u0027t expose CgroupMap outside of libprocessgroup considering it\u0027s an implementation detail. If needed I can move cgroup_map.h header into include/processgroup/ and eliminate these functions.",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 64,
        "endChar": 2
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5cc4d54d_2baf0f96",
        "filename": "libprocessgroup/processgroup.cpp",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1119068
      },
      "writtenOn": "2019-01-17T12:34:57Z",
      "side": 1,
      "message": "I think the important part is to not leak hard-coded paths... while exposing CgroupMap I think is still possible and actually probably makes more sense and keep things simple for cases like the eBPF integration.\nMore details on my last comment for:\n   libbpf_android/BpfUtils.cpp::loadAndPinProgram()",
      "parentUuid": "59c016b7_586107eb",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 64,
        "endChar": 2
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd6111ca_c83d8ea0",
        "filename": "libprocessgroup/processgroup.cpp",
        "patchSetId": 6
      },
      "lineNbr": 409,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2019-01-18T03:10:50Z",
      "side": 1,
      "message": "I checked all usages of Attributes and there are two places where we really need them. This is one of them. The setProcessGroupXXX API below is very unfortunate. If assumes per-application hierarchy (because it controls a cgroup parameter per pid) and it also assumes that these parameters are available.\n\nThe second place we do need Attributes is https://android-review.googlesource.com/c/platform/frameworks/base/+/861909/4/core/jni/android_util_Process.cpp#355",
      "range": {
        "startLine": 409,
        "startChar": 9,
        "endLine": 409,
        "endChar": 38
      },
      "revId": "ead2a81923e11e2c6a78d9f10498e5dcc4f3c47c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}