{
  "comments": [
    {
      "key": {
        "uuid": "a45533f7_64754495",
        "filename": "trusty/confirmationui/Android.bp",
        "patchSetId": 4
      },
      "lineNbr": 3,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T05:09:56Z",
      "side": 1,
      "message": "AOSP license pls",
      "range": {
        "startLine": 3,
        "startChar": 0,
        "endLine": 3,
        "endChar": 39
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e27d4cd1_52d4f359",
        "filename": "trusty/confirmationui/Android.bp",
        "patchSetId": 4
      },
      "lineNbr": 3,
      "author": {
        "id": 1092085
      },
      "writtenOn": "2020-01-15T22:39:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a45533f7_64754495",
      "range": {
        "startLine": 3,
        "startChar": 0,
        "endLine": 3,
        "endChar": 39
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f8b250e7_53ff5d2c",
        "filename": "trusty/confirmationui/TrustyApp.cpp",
        "patchSetId": 4
      },
      "lineNbr": 95,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T05:09:56Z",
      "side": 1,
      "message": "Somewhat counter-intuitive given that at this point the response message has not been received, i.e. should be a lot remaining",
      "range": {
        "startLine": 95,
        "startChar": 24,
        "endLine": 95,
        "endChar": 25
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c233367a_527f8fa6",
        "filename": "trusty/confirmationui/TrustyApp.cpp",
        "patchSetId": 4
      },
      "lineNbr": 95,
      "author": {
        "id": 1092085
      },
      "writtenOn": "2020-01-15T22:39:08Z",
      "side": 1,
      "message": "We don\u0027t know how much is remaining at this point. Because we don\u0027t know how much data the app will send us.",
      "parentUuid": "f8b250e7_53ff5d2c",
      "range": {
        "startLine": 95,
        "startChar": 24,
        "endLine": 95,
        "endChar": 25
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b10f9506_aecad848",
        "filename": "trusty/confirmationui/TrustyApp.cpp",
        "patchSetId": 4
      },
      "lineNbr": 100,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T05:09:56Z",
      "side": 1,
      "message": "s/0/remaining\nor remove",
      "range": {
        "startLine": 100,
        "startChar": 25,
        "endLine": 100,
        "endChar": 26
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c8efdf16_19548083",
        "filename": "trusty/confirmationui/TrustyApp.cpp",
        "patchSetId": 4
      },
      "lineNbr": 100,
      "author": {
        "id": 1092085
      },
      "writtenOn": "2020-01-15T22:39:08Z",
      "side": 1,
      "message": "This field is unused for PacketType::RCV. We only tell the app that we expect data but not how much.",
      "parentUuid": "b10f9506_aecad848",
      "range": {
        "startLine": 100,
        "startChar": 25,
        "endLine": 100,
        "endChar": 26
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5d7e88cd_faf89ba7",
        "filename": "trusty/confirmationui/TrustyApp.h",
        "patchSetId": 4
      },
      "lineNbr": 18,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T05:09:56Z",
      "side": 1,
      "message": "nit: \"#pragma\" once for consistency",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 18,
        "endChar": 29
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa92fe8a_d2d21ba6",
        "filename": "trusty/confirmationui/TrustyApp.h",
        "patchSetId": 4
      },
      "lineNbr": 66,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T05:09:56Z",
      "side": 1,
      "message": "It seems intuitive to me to assume that \"o\" and \"i\" stand for output and input. It doesn\u0027t make sense here though?",
      "range": {
        "startLine": 65,
        "startChar": 30,
        "endLine": 66,
        "endChar": 31
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4c586137_4af5aedd",
        "filename": "trusty/confirmationui/TrustyApp.h",
        "patchSetId": 4
      },
      "lineNbr": 66,
      "author": {
        "id": 1092085
      },
      "writtenOn": "2020-01-15T22:39:08Z",
      "side": 1,
      "message": "Depends on your perspective. I was more thinking of the caller/API user. For them, obegin/oend is buffer is the buffer they send out, while the second buffer is input. Analog: you write to stdout or std::cout.\n\nWould it be more intuitive to call them wXXX and rXXX for write and read buffer?",
      "parentUuid": "aa92fe8a_d2d21ba6",
      "range": {
        "startLine": 65,
        "startChar": 30,
        "endLine": 66,
        "endChar": 31
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "89dba893_4652f6c2",
        "filename": "trusty/confirmationui/TrustyApp.h",
        "patchSetId": 4
      },
      "lineNbr": 72,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T05:09:56Z",
      "side": 1,
      "message": "Assuming that this mutex protects the handle, it should also be locked in start() and the destructor()",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 72,
        "endChar": 22
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d79cba0e_6f974f01",
        "filename": "trusty/confirmationui/TrustyApp.h",
        "patchSetId": 4
      },
      "lineNbr": 72,
      "author": {
        "id": 1092085
      },
      "writtenOn": "2020-01-15T22:39:08Z",
      "side": 1,
      "message": "Making sending commands during construction or deletion would be undefined behavior regardless of the mutex. Users of TrustyApp must keep keep the object alive when sending commands. They typically do so by acquiring a strong std::shared_ptr reference to the TrustyApp.\n\nThat said though I realize that the handle a) not created and construction and b) not checked by the command functions before it is used.\n\nI changed both now.",
      "parentUuid": "89dba893_4652f6c2",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 72,
        "endChar": 22
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "107ae220_58f55d23",
        "filename": "trusty/confirmationui/TrustyApp.h",
        "patchSetId": 4
      },
      "lineNbr": 99,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T05:09:56Z",
      "side": 1,
      "message": "nit: use lock_guard to make it clear that the mutex is not unlocked until the end of the scope",
      "range": {
        "startLine": 99,
        "startChar": 0,
        "endLine": 99,
        "endChar": 50
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7be91650_9ab27b33",
        "filename": "trusty/confirmationui/TrustyApp.h",
        "patchSetId": 4
      },
      "lineNbr": 99,
      "author": {
        "id": 1092085
      },
      "writtenOn": "2020-01-15T22:39:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "107ae220_58f55d23",
      "range": {
        "startLine": 99,
        "startChar": 0,
        "endLine": 99,
        "endChar": 50
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fb39e968_ddcd64a1",
        "filename": "trusty/confirmationui/TrustyApp.h",
        "patchSetId": 4
      },
      "lineNbr": 154,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T05:09:56Z",
      "side": 1,
      "message": "remove",
      "range": {
        "startLine": 151,
        "startChar": 0,
        "endLine": 154,
        "endChar": 59
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cca72200_3ed4c51e",
        "filename": "trusty/confirmationui/TrustyApp.h",
        "patchSetId": 4
      },
      "lineNbr": 154,
      "author": {
        "id": 1092085
      },
      "writtenOn": "2020-01-15T22:39:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fb39e968_ddcd64a1",
      "range": {
        "startLine": 151,
        "startChar": 0,
        "endLine": 154,
        "endChar": 59
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cf1f4f38_528328fb",
        "filename": "trusty/confirmationui/TrustyConfirmationUI.cpp",
        "patchSetId": 4
      },
      "lineNbr": 85,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T18:03:59Z",
      "side": 1,
      "message": "Remove if unused",
      "range": {
        "startLine": 85,
        "startChar": 0,
        "endLine": 85,
        "endChar": 31
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9d23a674_ad4c0818",
        "filename": "trusty/confirmationui/TrustyConfirmationUI.cpp",
        "patchSetId": 4
      },
      "lineNbr": 297,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T05:09:56Z",
      "side": 1,
      "message": "document this magic number",
      "range": {
        "startLine": 297,
        "startChar": 17,
        "endLine": 297,
        "endChar": 19
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a863ef29_401e05a1",
        "filename": "trusty/confirmationui/TrustyConfirmationUI.cpp",
        "patchSetId": 4
      },
      "lineNbr": 324,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T18:03:59Z",
      "side": 1,
      "message": "Did you mean to lock the mutex?",
      "range": {
        "startLine": 324,
        "startChar": 0,
        "endLine": 324,
        "endChar": 22
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3131747d_dc97dbce",
        "filename": "trusty/confirmationui/TrustyConfirmationUI.cpp",
        "patchSetId": 4
      },
      "lineNbr": 324,
      "author": {
        "id": 1092085
      },
      "writtenOn": "2020-01-15T22:39:08Z",
      "side": 1,
      "message": "Woops how did this get here?",
      "parentUuid": "a863ef29_401e05a1",
      "range": {
        "startLine": 324,
        "startChar": 0,
        "endLine": 324,
        "endChar": 22
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "593cd234_e3acc737",
        "filename": "trusty/confirmationui/TrustyConfirmationUI.cpp",
        "patchSetId": 4
      },
      "lineNbr": 366,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T18:03:59Z",
      "side": 1,
      "message": "You need to have evResultLock locked here too.\n\nIt might be cleaner to treat eventRC as part of state of the HAL (like abort_called_ and secureInputDelivered_) and protect it with stateLock.",
      "range": {
        "startLine": 366,
        "startChar": 15,
        "endLine": 366,
        "endChar": 22
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dce4778c_9fa49d37",
        "filename": "trusty/confirmationui/TrustyConfirmationUI.cpp",
        "patchSetId": 4
      },
      "lineNbr": 366,
      "author": {
        "id": 1092085
      },
      "writtenOn": "2020-01-15T22:39:08Z",
      "side": 1,
      "message": "good catch. However, there is a potential deadlock if the eventRC is also protected by stateLock. Replaced with an atomic.",
      "parentUuid": "593cd234_e3acc737",
      "range": {
        "startLine": 366,
        "startChar": 15,
        "endLine": 366,
        "endChar": 22
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2fbb58c6_0bfefb84",
        "filename": "trusty/confirmationui/TrustyConfirmationUI.cpp",
        "patchSetId": 4
      },
      "lineNbr": 466,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T18:03:59Z",
      "side": 1,
      "message": "Does this mean that we queue events while we\u0027re in non-interactive state? If so, why?",
      "range": {
        "startLine": 466,
        "startChar": 44,
        "endLine": 466,
        "endChar": 96
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d56c9f1_94ab0a24",
        "filename": "trusty/confirmationui/TrustyConfirmationUI.cpp",
        "patchSetId": 4
      },
      "lineNbr": 466,
      "author": {
        "id": 1092085
      },
      "writtenOn": "2020-01-15T22:39:08Z",
      "side": 1,
      "message": "deliverSecureInputEvent is only used by the VTS test to mock human input. (A correct implementation responds with a mock confirmation token signed with a test key). The problem is that the non interactive grace period was not formalized in the HAL spec, so that the VTS test does not account for the grace period. (It probably should.) This means we can only pass the VTS test if we block until the grace period is over (SetupDone -\u003e Interactive) before we deliver the input event.\n\nThe true secure input is delivered by a different mechanism and gets ignored - not queued - until the grace period is over.\n\nI should add this as a comment.",
      "parentUuid": "2fbb58c6_0bfefb84",
      "range": {
        "startLine": 466,
        "startChar": 44,
        "endLine": 466,
        "endChar": 96
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "15fff9e3_a32a45f9",
        "filename": "trusty/confirmationui/TrustyConfirmationUI.cpp",
        "patchSetId": 4
      },
      "lineNbr": 473,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T18:03:59Z",
      "side": 1,
      "message": "Do we only use this function for testing on Trusty-based devices?",
      "range": {
        "startLine": 472,
        "startChar": 0,
        "endLine": 473,
        "endChar": 82
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b71665c8_d0ab78e8",
        "filename": "trusty/confirmationui/TrustyConfirmationUI.cpp",
        "patchSetId": 4
      },
      "lineNbr": 473,
      "author": {
        "id": 1092085
      },
      "writtenOn": "2020-01-15T22:39:08Z",
      "side": 1,
      "message": "Yes, and not only on trusty based devices. deliverSecureInputEvent was formerly designed to use an AuthToken, e.g., from the fingerprint sensor as confirming input. But we moved away from this approach when it was too late to change the HAL spec. Vendor implementations can technically still do this. But we don\u0027t.",
      "parentUuid": "15fff9e3_a32a45f9",
      "range": {
        "startLine": 472,
        "startChar": 0,
        "endLine": 473,
        "endChar": 82
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d7782ed_66f206a4",
        "filename": "trusty/confirmationui/TrustyConfirmationUI.cpp",
        "patchSetId": 4
      },
      "lineNbr": 493,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2020-01-15T18:03:59Z",
      "side": 1,
      "message": "Why can\u0027t abort be called during other stages?",
      "range": {
        "startLine": 492,
        "startChar": 0,
        "endLine": 493,
        "endChar": 60
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "07cf5c1e_2eca88af",
        "filename": "trusty/confirmationui/TrustyConfirmationUI.cpp",
        "patchSetId": 4
      },
      "lineNbr": 493,
      "author": {
        "id": 1092085
      },
      "writtenOn": "2020-01-15T22:39:08Z",
      "side": 1,
      "message": "It would not have an effect. We cannot get to this point while in \"Starting\" because throughout this phase the binder thread is busy starting the confirmation dialog. After \"Interactive\" the dialog is going down anyway. So the only time abort would have an effect is during the grace period (SetupDone) or while the dialog is interactive.\n\nThe postcondition of abort() is that no confirmation operation is active, This is already true or about to come true in all other states, and listener_state_ \u003d\u003d Starting cannot be reached here.",
      "parentUuid": "2d7782ed_66f206a4",
      "range": {
        "startLine": 492,
        "startChar": 0,
        "endLine": 493,
        "endChar": 60
      },
      "revId": "0758ec5e6f3adbe1b30f02a2c9f3556aabfa686a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}